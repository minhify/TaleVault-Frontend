{"version":3,"sources":["../../src/useQueries.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  ref,\n  watch,\n} from 'vue-demi'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\nimport type { DistributiveOmit, MaybeRefDeep } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = DistributiveOmit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        TError,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? QueryObserverResult<TData, unknown extends TError ? DefaultError : TError>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, any>\n        throwOnError?: ThrowOnError<any, infer TError, any, any>\n      }\n    ? QueryObserverResult<\n        TQueryFnData,\n        unknown extends TError ? DefaultError : TError\n      >\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : Array<unknown> extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends Array<\n      UseQueryOptionsForUseQueries<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        infer TQueryKey\n      >\n    >\n  ? Array<UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>>\n  : // Fallback\n    Array<UseQueryOptionsForUseQueries>\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends Array<\n      UseQueryOptionsForUseQueries<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        any\n      >\n    >\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    Array<\n      QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>\n    >\n  : // Fallback\n    Array<QueryObserverResult>\n\ntype UseQueriesOptionsArg<T extends Array<any>> = readonly [\n  ...UseQueriesOptions<T>,\n]\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = UseQueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: MaybeRefDeep<UseQueriesOptionsArg<T>>\n    combine?: (result: UseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): Readonly<Ref<TCombinedResult>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedQueries = computed(() =>\n    cloneDeepUnref(queries).map((queryOptions) => {\n      if (typeof queryOptions.enabled === 'function') {\n        queryOptions.enabled = queryOptions.enabled()\n      }\n\n      const defaulted = client.defaultQueryOptions(queryOptions)\n      defaulted._optimisticResults = client.isRestoring.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    }),\n  )\n\n  const observer = new QueriesObserver<TCombinedResult>(\n    client,\n    defaultedQueries.value,\n    options as QueriesObserverOptions<TCombinedResult>,\n  )\n  const [, getCombinedResult] = observer.getOptimisticResult(\n    defaultedQueries.value,\n  )\n  const state = ref(getCombinedResult()) as Ref<TCombinedResult>\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    client.isRestoring,\n    (isRestoring) => {\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe(() => {\n          const [, getCombinedResultRestoring] = observer.getOptimisticResult(\n            defaultedQueries.value,\n          )\n          state.value = getCombinedResultRestoring()\n        })\n        // Subscription would not fire for persisted results\n        const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n          defaultedQueries.value,\n        )\n        state.value = getCombinedResultPersisted()\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    defaultedQueries,\n    () => {\n      observer.setQueries(\n        defaultedQueries.value,\n        options as QueriesObserverOptions<TCombinedResult>,\n      )\n      const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n        defaultedQueries.value,\n      )\n      state.value = getCombinedResultPersisted()\n    },\n    { flush: 'sync' },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as Readonly<Ref<TCombinedResult>>\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAAgC;AAChC,sBAOO;AAEP,4BAA+B;AAC/B,mBAA+B;AAyKxB,SAAS,WAId;AAAA,EACE;AAAA,EACA,GAAG;AACL,GAIA,aACgC;AAChC,MAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,QAAI,KAAC,iCAAgB,GAAG;AACtB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,mBAAe,sCAAe;AAE7C,QAAM,uBAAmB;AAAA,IAAS,UAChC,6BAAe,OAAO,EAAE,IAAI,CAAC,iBAAiB;AAC5C,UAAI,OAAO,aAAa,YAAY,YAAY;AAC9C,qBAAa,UAAU,aAAa,QAAQ;AAAA,MAC9C;AAEA,YAAM,YAAY,OAAO,oBAAoB,YAAY;AACzD,gBAAU,qBAAqB,OAAO,YAAY,QAC9C,gBACA;AAEJ,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,QAAM,WAAW,IAAI;AAAA,IACnB;AAAA,IACA,iBAAiB;AAAA,IACjB;AAAA,EACF;AACA,QAAM,CAAC,EAAE,iBAAiB,IAAI,SAAS;AAAA,IACrC,iBAAiB;AAAA,EACnB;AACA,QAAM,YAAQ,qBAAI,kBAAkB,CAAC;AAErC,MAAI,cAAc,MAAM;AAAA,EAExB;AAEA;AAAA,IACE,OAAO;AAAA,IACP,CAAC,gBAAgB;AACf,UAAI,CAAC,aAAa;AAChB,oBAAY;AACZ,sBAAc,SAAS,UAAU,MAAM;AACrC,gBAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,YAC9C,iBAAiB;AAAA,UACnB;AACA,gBAAM,QAAQ,2BAA2B;AAAA,QAC3C,CAAC;AAED,cAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,UAC9C,iBAAiB;AAAA,QACnB;AACA,cAAM,QAAQ,2BAA2B;AAAA,MAC3C;AAAA,IACF;AAAA,IACA,EAAE,WAAW,KAAK;AAAA,EACpB;AAEA;AAAA,IACE;AAAA,IACA,MAAM;AACJ,eAAS;AAAA,QACP,iBAAiB;AAAA,QACjB;AAAA,MACF;AACA,YAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,QAC9C,iBAAiB;AAAA,MACnB;AACA,YAAM,QAAQ,2BAA2B;AAAA,IAC3C;AAAA,IACA,EAAE,OAAO,OAAO;AAAA,EAClB;AAEA,sCAAe,MAAM;AACnB,gBAAY;AAAA,EACd,CAAC;AAED,aAAO,0BAAS,KAAK;AACvB;","names":[]}